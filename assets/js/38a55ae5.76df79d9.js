"use strict";(self.webpackChunkpixelorama_docs=self.webpackChunkpixelorama_docs||[]).push([[558],{8027:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=s(5893),t=s(1151);const o={id:"extension_basics",title:"Extension Basics",sidebar_label:"Extension Basics",sidebar_position:1},r=void 0,a={id:"extension_system/extension_basics",title:"Extension Basics",description:"Making an Extension",source:"@site/docs/extension_system/extension_basics.md",sourceDirName:"extension_system",slug:"/extension_system/extension_basics",permalink:"/Pixelorama-Docs/extension_system/extension_basics",draft:!1,unlisted:!1,editUrl:"https://github.com/Orama-Interactive/Pixelorama-Docs/edit/master/docs/extension_system/extension_basics.md",tags:[],version:"current",lastUpdatedBy:"Daniel",lastUpdatedAt:1701610236,formattedLastUpdatedAt:"Dec 3, 2023",sidebarPosition:1,frontMatter:{id:"extension_basics",title:"Extension Basics",sidebar_label:"Extension Basics",sidebar_position:1},sidebar:"docs",previous:{title:"Project",permalink:"/Pixelorama-Docs/concepts/project"},next:{title:"ExtensionsApi",permalink:"/Pixelorama-Docs/extension_system/extension_api"}},l={},d=[{value:"Making an Extension",id:"making-an-extension",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Process",id:"process",level:3},{value:"The File Structure of any basic extension.",id:"the-file-structure-of-any-basic-extension",level:5},{value:"extension.json",id:"extensionjson",level:3},{value:"Main.tscn",id:"maintscn",level:3},{value:"Main.gd",id:"maingd",level:3},{value:"Limitations and Workarounds",id:"limitations-and-workarounds",level:2},{value:"Exporting the Extension",id:"exporting-the-extension",level:2},{value:"Extension Export Options.",id:"extension-export-options",level:5},{value:"Installing the Extension",id:"installing-the-extension",level:2},{value:"Adding an Extension.",id:"adding-an-extension",level:5},{value:"Debugging an Extension",id:"debugging-an-extension",level:2},{value:"Debugging of an extension (stack trace shown as a result of non existent function).",id:"debugging-of-an-extension-stack-trace-shown-as-a-result-of-non-existent-function",level:5}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"making-an-extension",children:"Making an Extension"}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.strong,{children:"Pixelorama v0.10"}),", you can add/remove extensions to/from Pixelorama. Extensions are distributed as PCK (.pck) or ZIP (.zip) files and you can manage them from ",(0,i.jsx)(n.strong,{children:"Edit > Preferences > Extensions"}),'. This is a step-by-step guide of how you can make an extension for pixelorama. For this tutorial the extension we\'ll make will be called "Example"']}),"\n",(0,i.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"First of all, there are a few prerequisites for you to start creating extensions."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Some knowledge of GdScript."}),"\n",(0,i.jsxs)(n.li,{children:["A ready to use ",(0,i.jsx)(n.a,{href:"https://godotengine.org/",children:"Godot executable"})," (See the ",(0,i.jsx)(n.a,{href:"https://github.com/Orama-Interactive/Pixelorama/blob/master/CHANGELOG.md",children:"Pixelorama Channgelog"})," to figure out which version to use)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/Orama-Interactive/Pixelorama",children:"Source code of Pixelorama"})," (This is optional but will speed up your debugging workflow)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"process",children:"Process"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'First of all make a new Godot project of name "Example" (the project name is irrelevant but for simplicity we\'ll name it the same as our extension).'}),"\n",(0,i.jsx)(n.li,{children:"After that make a directory structure as shown in the image below."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Extension File Structure",src:s(2051).Z+"",width:"775",height:"165"})}),"\n",(0,i.jsx)(n.h5,{id:"the-file-structure-of-any-basic-extension",children:"The File Structure of any basic extension."}),"\n",(0,i.jsx)(n.p,{children:'In the "Example" folder you can see three files;'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"extension.json"}),"\n",(0,i.jsx)(n.li,{children:"Main.tscn"}),"\n",(0,i.jsx)(n.li,{children:"Main.gd"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These files are the bare minimum required for an extension to function properly. Let's go through each of them one by one:"}),"\n",(0,i.jsx)(n.h3,{id:"extensionjson",children:"extension.json"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"extension.json"})," file serves as a basic configuration file for the extension. A proper ",(0,i.jsx)(n.code,{children:"extension.json"})," file should contain the below content"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n    "name": "Example",\n    "display_name": "Anything you want",\n    "description": "What the extension does",\n    "author": "Your Name",\n    "version": "0.1",\n\t"supported_api_versions": [3],\n    "license": "MIT",\n    "nodes": [\n        "Main.tscn"\n    ]\n}\n'})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Key"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"The extension name (in this case Example)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"display_name"}),(0,i.jsx)(n.td,{children:"The name actually shown by pixelorama in it's extension list (it can be anything)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"author"}),(0,i.jsx)(n.td,{children:"Author of the extension"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"version"}),(0,i.jsx)(n.td,{children:"version of the extension, it is a floating value so versions like 1.0.3 etc. are invalid"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"supported_api_versions"}),(0,i.jsx)(n.td,{children:"(Optional) Announces the Api level of the extension"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"license"}),(0,i.jsx)(n.td,{children:"Name of license used by the extension"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"nodes"}),(0,i.jsxs)(n.td,{children:["Array containing name of scenes that should be instanced as soon extension gets enabled (in this case it is ",(0,i.jsx)(n.code,{children:"Main.tscn"}),")"]})]})]})]}),"\n",(0,i.jsx)(n.admonition,{title:"Api Versions",type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"supported_api_versions"})," is an optional key that is used by pixelorama to determine if it is compatible with it's Api ( E.g ",(0,i.jsx)(n.code,{children:"[ 3 ]"})," means you are making extension for Pixelorama 0.11.x). If your extension is compatible with multiple api e.g (level 2 and 3) then use ",(0,i.jsx)(n.code,{children:"[ 2, 3 ]"}),". To find the Api level of pixelorama open the ",(0,i.jsx)(n.code,{children:"project.godot"})," file in ",(0,i.jsx)(n.strong,{children:"Pixelorama's Source"})," and look for ",(0,i.jsx)(n.code,{children:"config/ExtensionsAPI_Version"})]})}),"\n",(0,i.jsx)(n.h3,{id:"maintscn",children:"Main.tscn"}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned above, the ",(0,i.jsx)(n.code,{children:"Main.tscn"})," will be instanced in pixelorama as soon as the extension gets enabled. a GdScript file (In this case ",(0,i.jsx)(n.code,{children:"Main.gd"}),") is attached to this scene."]}),"\n",(0,i.jsx)(n.h3,{id:"maingd",children:"Main.gd"}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned above, the ",(0,i.jsx)(n.code,{children:"Main.gd"})," is a script written in GdScript, that will be run as soon as the extension gets enabled. It can be used to"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Instance further scenes (.tscn files)."}),"\n",(0,i.jsx)(n.li,{children:"Or contain the core extension code."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The content of a basic ",(0,i.jsx)(n.code,{children:"Main.gd"})," file is;"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'extends Node\n\n# NOTE: use get_node_or_null("/root/ExtensionsApi") to access the extension api.\n\n# Runs as soon as extension is enabled. This script can act as a setup for the extension.\nfunc _enter_tree() -> void:\n\tpass\n\n\nfunc _exit_tree() -> void:  # Extension is being uninstalled or disabled\n\t# remember to remove things that you added using this extension\n\tpass\n'})}),"\n",(0,i.jsx)(n.h2,{id:"limitations-and-workarounds",children:"Limitations and Workarounds"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["New custom classes (e.g ",(0,i.jsx)(n.code,{children:"class_name Foo"}),") can't be created in the extension, but there is a workaround. Don't assign scripts custom class names and instead of doing ",(0,i.jsx)(n.code,{children:"Foo.new()"})," if say your script ",(0,i.jsx)(n.em,{children:'"Foo.gd"'})," is located at ",(0,i.jsx)(n.code,{children:"res://src/Extensions/Example/CustomClasses/Foo.gd"})," then you can use"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"preload(res://src/Extensions/Example/CustomClasses/Foo.gd).new()\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["If your extension needs to use pixelorama's classes (e.g ",(0,i.jsx)(n.code,{children:"Project"}),", ",(0,i.jsx)(n.code,{children:"BaseCel"}),", ",(0,i.jsx)(n.code,{children:"BaseTool"})," etc) make empty class scripts and place them in ",(0,i.jsx)(n.code,{children:"res://src/Extensions/Example/EmptyClasses/"}),". For example an empty class scripts of ",(0,i.jsx)(n.code,{children:"Project"})," class will look like;"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# This is example of an empty Project class\nclass_name Project\nextends Reference\n\n# Empty Variables (variable containing only name and type but no value)\n# obviously they are not all of Project class variables\n# They are written to remove (Variable not found in class: Project) errors\n# (add more variables from the real Project class if your extension needs them)\nvar name: String\nvar size: Vector2\nvar undo_redo: UndoRedo\nvar tiles: Tiles\nvar undos: int\nvar can_undo: bool\nvar fill_color: Color\nvar has_changed: bool\n\n\n# Empty functions (they don't contain any actual code)\n# obviously they are not all of Project class functions,\n# They are written to remove (Method not found in class: Project) errors\n# (add more functions below from the real Project class if your extension needs them)\nfunc _init(_frames := [], _name := tr(\"untitled\"), _size := Vector2(64, 64)) -> void:\n\treturn  # As the functions returns void, we are using return without a value\n\n\nfunc remove() -> void:\n\treturn  # As the functions returns void, we are using return without a value\n\n\nfunc serialize() -> Dictionary:\n\t# As the functions returns a value, we are returning the most basic value of the same type.\n\t# for a Dictionary, it's smallest value is just an empty dictionary\n\treturn {}\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"exporting-the-extension",children:"Exporting the Extension"}),"\n",(0,i.jsx)(n.p,{children:"Now that you have the basic extension code ready, let's export it;"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["From the top bar in Godot editor go to ",(0,i.jsx)(n.strong,{children:"Project > Export"})," and choose any platform option (the extension should work on other platforms regardless of which platform you choose)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In then go to the ",(0,i.jsx)(n.strong,{children:"Resources"})," tab and do the following changes;"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Export Mode"})," should be set to ",(0,i.jsx)(n.code,{children:"Export all resources in the project"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Filters to export non-resource files/folders"})," should be set to ",(0,i.jsx)(n.code,{children:"*.json"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Filters to exclude files/folders from project"})," should be set to ",(0,i.jsx)(n.code,{children:"res://src/Extensions/Example/EmptyClasses/*"}),"\n",(0,i.jsx)(n.img,{alt:"Extension Export Options",src:s(3967).Z+"",width:"552",height:"385"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"extension-export-options",children:"Extension Export Options."}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["After that, press ",(0,i.jsx)("kbd",{children:"Export PCK/Zip"})," and export it as a PCK file (both Zip and PCK extensions are recognized by pixelorama but PCK is recommended). The name of exported pck should be the same as the ",(0,i.jsx)(n.code,{children:"name"})," of your extension, in this case it should be ",(0,i.jsx)(n.code,{children:"Example.pck"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"installing-the-extension",children:"Installing the Extension"}),"\n",(0,i.jsxs)(n.p,{children:["To install an extension, from pixelorama's top menu go to ",(0,i.jsx)(n.strong,{children:"Edit > Preferences > Extensions"})," and click ",(0,i.jsx)("kbd",{children:"Add Extension"}),"."]}),"\n",(0,i.jsx)(n.admonition,{title:"Drag and Drop",type:"tip",children:(0,i.jsx)(n.p,{children:"A more easier way would be to drag and drop the extension in Pixelorama."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Extension Export Options",src:s(5853).Z+"",width:"604",height:"427"})}),"\n",(0,i.jsx)(n.h5,{id:"adding-an-extension",children:"Adding an Extension."}),"\n",(0,i.jsxs)(n.p,{children:["After it has appeared in the list of extensions, select it press ",(0,i.jsx)("kbd",{children:"Enable"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"debugging-an-extension",children:"Debugging an Extension"}),"\n",(0,i.jsxs)(n.p,{children:["In order to debug an extension, you need to have the source-code of your target version of Pixelorama open in another godot instance. To start debugging, ",(0,i.jsx)(n.strong,{children:"run pixelorama from godot"})," and follow the steps in ",(0,i.jsx)(n.a,{href:"#installing-the-extension",children:"Installing the Extension"}),". The debugger of Godot instance housing pixelorama's source-code will be used to debug the extension."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Extension Export Options",src:s(2623).Z+"",width:"1026",height:"566"})}),"\n",(0,i.jsx)(n.h5,{id:"debugging-of-an-extension-stack-trace-shown-as-a-result-of-non-existent-function",children:"Debugging of an extension (stack trace shown as a result of non existent function)."})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},5853:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/add_extension-deb6ce1c9f212175bb7b8eb8c3abe287.png"},2623:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/extension_debugging-c22e3077a3da7942bc6ec85601543e5b.png"},3967:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/extension_export-955370c71a730bdd4d0d9b81e6ac5f18.png"},2051:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/extension_structure-5c24b4ccd29fb2aef2f9168b344c3e17.png"},1151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>r});var i=s(7294);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);